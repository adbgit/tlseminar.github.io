<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>The Future of TLS  &middot; TLSeminar</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="description" content="" />

<meta name="keywords" content="">


<meta property="og:title" content="The Future of TLS  &middot; TLSeminar ">
<meta property="og:site_name" content="TLSeminar"/>
<meta property="og:url" content="https://tlseminar.github.io/tls-future/" />
<meta property="og:locale" content="en-us">


<meta property="og:type" content="article" />
<meta property="og:description" content=""/>
<meta property="og:article:published_time" content="2017-04-25T00:00:00Z" />
<meta property="og:article:modified_time" content="2017-04-25T00:00:00Z" />

  

  
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<meta name="twitter:creator" content="@" />
<meta name="twitter:title" content="The Future of TLS" />
<meta name="twitter:description" content="" />
<meta name="twitter:url" content="https://tlseminar.github.io/tls-future/" />
<meta name="twitter:domain" content="https://tlseminar.github.io">
  

<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "Article",
    "headline": "The Future of TLS",
    "author": {
      "@type": "Person",
      "name": "http://profiles.google.com/+?rel=author"
    },
    "datePublished": "2017-04-25",
    "description": "",
    "wordCount":  2526 
  }
</script>


<link rel="canonical" href="https://tlseminar.github.io/tls-future/" />

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://tlseminar.github.io/touch-icon-144-precomposed.png">
<link href="https://tlseminar.github.io/favicon.png" rel="icon">

<meta name="generator" content="Hugo 0.17" />

  <!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link href='https://fonts.googleapis.com/css?family=Merriweather:300%7CRaleway%7COpen+Sans' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="https://tlseminar.github.io/css/font-awesome.min.css">
<link rel="stylesheet" href="https://tlseminar.github.io/css/style.css">


  
  <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
</head>
<body>
  <main id="main-wrapper" class="container main_wrapper has-sidebar">
    <header id="main-header" class="container main_header">
  <div class="container brand">
  <div class="container title h1-like">
  <a class="baselink" href="https://tlseminar.github.io">
  TLSeminar

</a>

</div>

  
<div class="container topline">
  
  Understanding and Securing TLS


</div>


</div>

  <nav class="container nav primary no-print">
  


  
<a href="https://tlseminar.github.io/syllabus">Syllabus</a>

<a href="https://tlseminar.github.io/schedule">Schedule</a>

<a href="https://tlseminar.github.io/teams">Teams</a>

<a href="https://tlseminar.github.io/readings/">Readings</a>

<a href="https://tlseminar.github.io/projects/">Projects</a>

<a href="https://tlseminar.github.io/post" title="Show list of posts">Posts</a>


</nav>

<div class="container nav secondary no-print">
  





















</div>


  

</header>


<article id="main-content" class="container main_content single">
  <header class="container hat">
  <h1><center>The Future of TLS
</center></h1>

  <div class="metas">
<time datetime="2017-04-25">25 Apr, 2017</time>


  
    &middot; by Team Mango
  
  <br>
  


</div>

</header>

  <div class="container content">
  

<h3 id="https-traffic-analysis">HTTPS Traffic Analysis</h3>

<blockquote>
<p>Brad Miller, Ling Huang, A. D. Joseph, and J. D. Tygar. <a href="https://www.petsymposium.org/2014/papers/Miller.pdf">
<em>I Know Why You Went to the Clinic: Risks and Realization of HTTPS Traffic Analysis</em></a>, Privacy Enhancing Technologies Symposium, 2014.</p>
</blockquote>

<p>Recent research has begun to cast doubt on the confidentiality provided by HTTPS.  Researchers from UC Berkeley found that it is possible to determine medical conditions, financial and legal affairs, and sexual orientation of visitors to popular HTTPS-secured websites.</p>

<p>To perform the attack on confidentiality, the researchers employed clustering techniques to reveal traffic patterns and then applied a Gaussian distribution to glean similarities between the targets’ browsing pattern and the researchers’ own traffic patterns.  As part of the attack, the researchers needed to visit the same websites as the targets and provide combinations of inputs until their traffic patterns matched those of the targets, within a statistical range of error.  They note that ISPs and large government organizations could feasibly gain access to such traffic patterns despite the low probability of another Internet user doing so.</p>

<p>Through detailed traffic analysis, third parties could theoretically fingerprint Internet users and extract valuable personal information from HTTPS-secured communications by exploiting a side channel—in this case, as in many others, timing information.</p>

<p>What’s more, this example is by far the only side-channel leak regarding HTTPS traffic—at least four other prominent works (the latest of which was published just this year!) examine multiple usage scenarios ranging from Netflix viewing history to search queries to Google Map requests:</p>

<ul>
<li>Andrew Reed, Michael Kranch. <a href="https://www.mjkranch.com/docs/CODASPY17_Kranch_Reed_IdentifyingHTTPSNetflix.pdf"><em>Identifying HTTPS-Protected Netflix Videos in Real-Time</em></a>. CODASPY 2017.</li>
<li>Shuo Chen, Rui Wang, XiaoFeng Wang, Kehuan Zhang. <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/WebAppSideChannel-final.pdf"><em>Side-Channel Leaks in Web Applications: a Reality Today, a Challenge Tomorrow</em></a>. <a href="http://oakland31.cs.virginia.edu/">31st IEEE Symposium on Security and Privacy</a> (&ldquo;Oakland&rdquo;) 2010.</li>
<li>IOActive Blog. <a href="http://blog.ioactive.com/2012/02/ssl-traffic-analysis-on-google-maps.html"><em>I can still see your actions on Google Maps over SSL</em></a>. February 2012.</li>
</ul>

<h3 id="more-traffic-analysis">More Traffic Analysis</h3>

<p>TLS traffic analysis can be applied in many scenarios, including:</p>

<ul>
<li>Distinguishing between clients on the fly</li>
<li>Forensics</li>
<li>Intrusion detection</li>
<li>Malware detection</li>
<li>Homogeneous platform verification</li>
<li>Honeypots</li>
</ul>

<p>Techniques such as deep packet inspection and TLS flow fingerprinting can be used to distinguish clients, identify whether the encrypted connection is attributed to a Malware or not, and also be used for forensics, intrusion detection and homogeneous platform verification.</p>

<h4 id="tls-fingerprinting">TLS fingerprinting</h4>

<blockquote>
<p><a href="https://blog.squarelemon.com/tls-fingerprinting/">Brotherston, L. (2015). Stealthier attacks and smarter defending with TLS fingerprinting.</a></p>
</blockquote>

<p>During an TLS handshake, most clients initiate a TLS handshake request in a unique way. TLS fingerprinting is usually used to recognize a particular client. In TLS fingerprinting, some elements of the Client Hello Packet are filtered and collected to build a database of signatures. The collected elements are usually the combination of TLS version, record TLS version, ciphersuites, compression options, list of extensions, elliptic curves and signature algorithms. The use of this combined elements is not only reliable in terms of remaining static for any particular client, but offers greater granularity than assessing ciphersuites alone, which has a substantially larger quantity of fingerprint collisions.</p>

<h3 id="ipsec-in-ipv6-light-at-the-end-of-the-vpn-tunnel">IPSec in IPv6: light at the end of the (VPN) tunnel?</h3>

<p>IPv6 is the latest version of the Internet Protocol (IP), and the future of the
Internet&rsquo;s identification and location systems; it is slowly overtaking its widely used predecessor, IPv4,
and promises to add significant security improvements in the form of the IP
Security specification (IPSec). IPSec is a suite which authenticates and
encrypts packets of data through a VPN tunnel over a network connection; a version of IPSec has been adapted for IPv4, though the issues
we consider concern IPSec&rsquo;s vulnerabilities in IPv6.</p>

<h4 id="ipsec-gateways">IPSec gateways</h4>

<p>A vulnerability in IPSec gateways were recently uncovered as the &ldquo;Packet Too
Big&rdquo;-&ldquo;Packet Too Small&rdquo; ICMP attack in <a href="http://ieeexplore.ieee.org/abstract/document/7036862/">GLOBECOM
2014</a>. As described in
the paper, an attacker with eavesdropping and injection access to IPSec encrypted packets
can force an IPSec gateway to drop to its minimum possible transmission specification
(Path Maximum Transition Unit) and cause major performance penalties and denial
of service to the host. The root cause of the attack is in the impossibility of
IPSec to distinguish legitimate ICMP packets from illegitimate packets, as well
as several contradictions the Path MTU is managed by end hosts when the MTU is
below the minimum packet size.</p>

<h4 id="vpn-vulnerabilities-in-ipsec">VPN vulnerabilities in IPSec</h4>

<blockquote>
<p>Vasile C. Perta, Marco V. Barbera, Gareth Tyson, Hamed Haddadi, and Alessandro Mei. <a href="https://www.degruyter.com/downloadpdf/j/popets.2015.1.issue-1/popets-2015-0006/popets-2015-0006.pdf"><em>A Glance through the VPN Looking Glass: IPv6 Leakage and DNS Hijacking in Commercial VPN clients</em></a>. Privacy Enhancing Technologies 2015.</p>
</blockquote>

<p>A paper in <a href="https://www.degruyter.com/downloadpdf/j/popets.2015.1.issue-1/popets-2015-0006/popets-2015-0006.pdf">PETS 2015</a>
uncovered several vulnerabilities in IPv6 traffic, including leakage and DNS
hijacking. The vulnerability relies on the nature of IPv4/6 dual stack
implementations on common operating systems.</p>

<p><center>
<img src="/images/vpnvuln.png" width=90% alt="VPN Vulnerabilities"><br>
<span class="caption">Source: <a href="https://www.degruyter.com/downloadpdf/j/popets.2015.1.issue-1/popets-2015-0006/popets-2015-0006.pdf">Perta et al.</a>, PETS 2015.</span>
</center></p>

<p>All VPN services surveyed rely on the correct configuration of the operating
system’s routing table. Worryingly, no attempt is made to secure this operation.
The simplest scenario is where the VPN client does not change the victim’s
default DNS configuration (e.g., HideMyAss over OpenVPN). In this case,
subverting DNS queries is trivial. The access point can simply use DHCP to set
the victim’s DNS server to one that it manages itself. The adversary will then
receive all DNS queries generated by the host.</p>

<p>The paper notes that &ldquo;The simplest countermeasure to IPv6 leakage is disabling
IPv6 traffic on the host.&rdquo; Perhaps more sensibly, VPN clients could alter the
IPv6 routing table to capture all traffic and prevent leakage from occurring.</p>

<h3 id="quic-quick-udp-internet-connections">QUIC (Quick UDP Internet Connections)</h3>

<p>Internet today relies on TCP as a backbone for secure connections over the web. But TCP protocol introduces latency due to synchronization for channel setup, even before TLS handshake. The figure below shows that an average TCP connection takes 56 ms before the TLS handshake begins. This type of latency is not acceptable in mobile devices or in an area with poor internet reception.
<center><img src="/images/future_of_tls/tls_handshake_time.png" alt="TLS Handshake Time" style="width:500px;"/><br>
<sup>TLS Handshake Time (Source: <a href="https://hpbn.co/transport-layer-security-tls/">https://hpbn.co/transport-layer-security-tls/</a>)</sup></center></p>

<p>This motivates the need for faster secure networking by reducing the number of round trips required to establish secure connection. QUIC aims to achieve this by using UDP as backbone instead of TCP.</p>

<h4 id="implementing-quic">Implementing QUIC</h4>

<p><a href="https://www.chromium.org/quic">QUIC</a> was introduced by Google and it relies on UDP for fast secure connection. UDP provides quick connection and can handle out of sequence packets but requires resending of failed packets to prevent packet loss. It is an excellent alternative for faster secure connection if security is taken care by the application and leaving UDP to take care of the packet transmission and recovery. This requires both server and client side change in application logic to ensure security. Google has already implemented its <a href="https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit">crypto-layer</a> and provides experimental libraries like <a href="https://github.com/devsisters/libquic"><code>libquic</code></a> and <a href="https://github.com/devsisters/goquic"><code>goquic</code></a>, but currently this can only be tested on Google servers.
<center><img src="/images/future_of_tls/QUIC.png" alt="QUIC protocol stack" style="width:500px;"/><br>
<sup>QUIC Protocol Stack (Source: <a href="https://ma.ttias.be/googles-quic-protocol-moving-web-tcp-udp/">https://ma.ttias.be/googles-quic-protocol-moving-web-tcp-udp/</a>)</sup></center></p>

<h3 id="interplanetary-file-system-ipfs">InterPlanetary File System (IPFS)</h3>

<blockquote>
<p><a href="https://ipfs.io/">https://ipfs.io/</a></p>
</blockquote>

<p>Looking forward to the future of web, it is possible that new models of the Internet will come into play. One such candidate model that is being developed today is the InterPlanetary File System (IPFS). The goal of IPFS replace the Hypertext Transfer Protocol (HTTP) and treat the web as though it is a filesystem and to make the web distributed. Let&rsquo;s unpack what this means and what IPFS can potentially do for the web.</p>

<h4 id="the-web-distributed">The Web, Distributed</h4>

<p>A key distinction to make between models of the web are the way &ldquo;nodes,&rdquo; or computers are linked together. On one end of the spectrum there is the centralized model where a single server contains all the content on the web and every computer must connect to it to retrieve a particular page. If this sounds dystopian and inefficient, it is. This single server would essentially have full say over what content gets to appear on the web and who gets access to it. Thankfully, that is not the model of the web we live under.</p>

<p><center><img src="https://www.researchgate.net/profile/Jason_Hoelscher/publication/260480880/figure/fig1/AS:297257619476480@1447883147178/Figure-1-Centralized-decentralized-and-distributed-network-models-by-Paul-Baran-1964.png" alt="Centralized, Decentralized, and Distributed Networks" style="width:500px;"/><br>
<sup><a href="http://www.rand.org/content/dam/rand/pubs/research_memoranda/2006/RM3420.pdf">On Distributed Communications - Baran</a></sup></center></p>

<p>Our web is better described as a decentralized network. There is no central authority in charge of all of the data on the web. Rather, there are millions of servers that host web pages that anyone can access (most of the time). Anyone can create a server and host whatever they want. As the web has evolved however, we see that this model is perhaps not as ideal as we might like; most of the servers that make up the web are controlled by a few server-providers such as Amazon, Google, and Microsoft. The servers of large corporations such as Facebook tend to function as content repositories for billions of people instead of each person controlling his or her identity on the web. As such, the network can be described with a long tail distribution:</p>

<p><center><img src="https://upload.wikimedia.org/wikipedia/commons/8/8a/Long_tail.svg" alt="Long Tail Distribution" style="width:500px;"/><br>
<sup><a href="https://upload.wikimedia.org/wikipedia/commons/8/8a/Long_tail.svg">Long Tail Distribution</a></sup></center></p>

<p>A few servers have the most traffic and the traffic of the remaining servers exponentially decreases and trails off to nil.</p>

<p>What IPFS proposes to do is to create a distributed internet, where the actual distribution of content is done on a peer-to-peer basis. All of the nodes in the network host a nearly-equal amount of content. So why is this good? In both the centralized and decentralized case, a computer must download a file from a single server and deal with that servers busyness. With a distributed network, the computer can instead download content simultaneously from many of its peers. With video delivery for example, the P2P approach could save up to 60% in bandwidth costs.</p>

<h4 id="the-web-preserved">The Web, Preserved</h4>

<p>The second idea that makes IPFS different is that it has historic versioning built in. If you&rsquo;re familiar with git and the way each file has a history associated with it, then this concept should be right at home for you. If not, then imagine it this way: say you run a blog and one day you decide to add a new post to it. Both the way your blog was without the new post and the way it is now with the new post are saved within the network. So why is this a good thing? Take the case of <a href="https://en.wikipedia.org/wiki/Yahoo!_GeoCities">Yahoo GeoCities</a>. Back in the early 2000s Yahoo provided GeoCities as a place where people could set up small websites and publish content to them. However in 2009 Yahoo decided that GeoCities was no longer a profitable business for it and shut it down. At the time there where about 38 million user-built pages on GeoCities. Any content that was not preserved by the <a href="https://archive.org/web/geocities.php">Internet Archive</a> was lost.</p>

<h4 id="how-it-works">How It Works</h4>

<p>When someone adds a file to the IPFS network, all of the blocks within the file are hashed. IPFS deduplicates files on entry so if any of the blocks are duplicates of some other block (as shown by comparing the hashes of the blocks), the duplicate block will not be re-added to the network. As mentioned, version history is tracked for every file so the blocks are given a version number (v1 in this example). The file is then distributed across the network to nodes that are &ldquo;interested in it.&rdquo; This means that only nodes set to store a particular topic will store the file and its blocks. Indexing information is also stored with each node so that the network as a whole is aware of which node is storing what information. If a lookup is done on the file then the network is queried for nodes storing the content corresponding to the unique hash associated with the file. If you are more interested in how IPFS works, I recommending taking a look at the <a href="https://github.com/ipfs/papers/raw/master/ipfs-cap2pfs/ipfs-p2p-file-system.pdf">IPFS whitepaper</a>.</p>

<h4 id="will-it-work">Will it Work?</h4>

<p>Technically, yes. The IPFS network is an actual thing that one can join and use now but it remains to be seen whether IPFS can gain widespread adoption. Currently, one of the major problems the network faces is that it is <em>slow</em> both for storing and querying content. This is partially due to the small size of the network, but also because of the overhead that comes from all of the necessary information, like the hashing of the files and their blocks, needed to support the network&rsquo;s functionality. Perhaps the largest problem is the deep entrenchment of the HTTP protocol. Nearly everything on the web uses HTTP for transporting content, and unless there is a clear and present need for a switch to a different architecture, IPFS may remain wishful thinking for a long while.</p>

<h3 id="multi-context-tls">Multi-Context TLS</h3>

<blockquote>
<p>David Naylor, Kyle Schomp, Matteo Varvello, Ilias Leontiadis, Jeremy Blackburn, Diego Lopez, Konstantina Papagiannaki, Pablo Rodriguez Rodriguez, and Peter Steenkiste. <a href="https://www.cs.cmu.edu/~dnaylor/mcTLS.pdf"><em>Multi-Context TLS (mcTLS): Enabling Secure In-Network Functionality in TLS</em></a>. SIGCOMM 2015.</p>
</blockquote>

<p>Normal TLS facilitates connections between only 2 communicating parties. However, in the wild, most connections pass through various middleboxes along the way that provide additional functionality, such as intrusion detection and parental controls. Current TLS connections with middleboxes require the middlebox to generate fake certificates for the intended site. The network administrator sets up each machine on the network with a custom root CA for the fake cert. The middlebox then connects to the site, meaning that the client doesn&rsquo;t know what happens in this part of the connection (ex: the middlebox could downgrade the connection).</p>

<p>In order for TLS to support middleboxes, it must incorporate two principles: least privilege and endpoint agreement.</p>

<h4 id="least-privilege">Least Privilege</h4>

<p><a href="https://www.cs.cmu.edu/~dnaylor/mcTLS.pdf">Multi-Context TLS</a> (mcTLS) implements least privilege by defining 3 types of connection users: readers, writers, and endpoints. In this setup, the endpoints are the client and the target server, while readers and writers are middleboxes. Readers have the least privilege (read-only), writers have additional wite privileges, and endpoints have full access to the network traffic. In mcTLS, readers encrypt the data and generate a MAC for the ciphertext. This MAC verifies that no 3rd-parties modified the data. Writers then create a second MAC for the reader traffic (ciphertext + reader_MAC), which confirms that the readers did not modify the data (since readers do not have write access). Finally, the endpoint also creates a MAC on the entire stream to act as a signal of whether any writers modified the data (although they do have permission). Readers and writers only receive the keys that they need to perform their operations, whereas enpoints receive all keys.</p>

<ul>
<li>MAC

<ul>
<li>Readers encrypt data, create MAC</li>
<li>Writers create MAC - verifies no 3rd parties modified data</li>
<li>Endpoints create MAC - signal of whether writers modified data (they are allowed to)</li>
</ul></li>
<li>Readers, writers only get keys they need - endpoints get all keys</li>
</ul>

<h4 id="endpoint-agreement">Endpoint Agreement</h4>

<p>mcTLS key distribution implements the principle of endpoint agreement. Each middlebox (reader or writer) only receives a subset of the connection keys determined by its functionality. Permissions, which are substantiated through the keys, must be explicitly granted to a middlebox by both the client and server. Each side (client and server) provides each middlebox with half of each key granted by that side&rsquo;s policy. The middlebox can only use keys (permissions) granted by both the client and server. Thus, the mcTLS Handshake Protocol includes key distribution for the middleboxes in addition to the client and server.</p>

<h4 id="performance">Performance</h4>

<p>mcTLS requires most keys to be distributed and therefore involves larger packets in the handshake. This packet size increases with the number of encryption contexts (permissions) and the number of middleboxes. However, the hanshake includes the same number of trips as the standard TLS handshake and therefore requires roughly the same amount of time.</p>

</div>


  <footer class="container">
  <div class="container navigation no-print">
  <h2>Navigation</h2>
  
  

    
    <a class="prev" href="https://tlseminar.github.io/tls-outside-the-web/" title="TLS Outside The Web">
      Previous
    </a>
    

    
    <a class="next" href="https://tlseminar.github.io/presentations/" title="Project Presentations Schedule">
      Next
    </a>
    

  


</div>

</footer>

</article>
      <footer id="main-footer" class="container main_footer">
  

  <div class="container nav foot no-print">
  

  <a class="toplink" href="#">back to top</a>

</div>

  <div class="container credits">
  
<div class="container footline">
  
  <p align="center">cs6501: TLSeminar | University of Virginia, Spring 2017 | <a href="https://www.cs.virginia.edu/evans">David Evans</a>


</div>


  

</div>

</footer>

    </main>
    




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3775212-1', 'auto');
  ga('send', 'pageview');

</script>


    
  </body>
</html>

